[{"fileName":"指南-教程-配置我们的Nav导航栏","fileRoute":"/guide/guide_01_navbar","zip_code":"Nav导航栏有什么作用？>Nav导航栏就类似于一级路由，点击上面导航栏的路由跳转能够跳转到指定页面下面是对于导航栏的详细配置首先是在`config.ts`中可以看见，我们的一级路由分为三个，然后在每一个一级路由文件夹下都需要加上一个`index.mdx`文件作为路由我们的首页对于主页，我们的`index.mdx`只需要提供几个元信息即可，后面会根据提供的元信息进行渲染页面，下面我们可以提供元信息给主页面来渲染而对于其他的主页面，我们可以在里面书写我们自己的mdx文档","objectID":"997794-684820c82cd049aaae3c84855873111d"},{"fileName":"指南-教程-配置我们的侧边栏","fileRoute":"/guide/guide_02_siderbar","zip_code":"对于侧边栏的配置，我们也是在`config.ts`中进行配置我们在下面的siderbar配置中，可以对应的配置一些侧边栏的路由下面是效果图：","objectID":"997794-03e12b870c6978e6355ff6da07b41259"},{"fileName":"实现原理-Rpress架构-搭建脚手架","fileRoute":"/theory/theory_01_build","zip_code":"#关于脚手架脚手架使用`CAC`书写`bin`字段在`packet.json`中在`/bin/rpress.js`中在`cli.ts`中然后`pnpmlink`链接到全局","objectID":"997794-0750825eda5cd8ba7da6bbfc0740b54f"},{"fileName":"实现原理-Rpress架构-关于Rpress系统架构","fileRoute":"/theory/theory_02_about","zip_code":">干了什么？将一个服务打包下面是组件中的代码：`App.tsx`A.tsx`B.tsx下面是`server-ssr.ts`，主要是提供打包函数`renderServerApp`，你可以提供一个路由路径（比如`/a`），然后`StaticRouter`组件就会根据该路径将这个路径对应的页面转换为html字符串下面是`client-ssr.ts`，下面的renderApp函数在开发环境下是直接使用react的render来给#root组件绑定react实例，从而添加交互然而在生产环境下，我们将组件分为可交互组件与不可交互组件；对于不可交互组件，其实就是一个静态的html，所以不需要向其提供hydrates（何为hydrates？就是给该组件绑定事件）；而对于可交互组件，我们就需要向其提供hydrates，比如说下面的A组件就是需要交互的组件实现的效果：对于App.tsx与B.tsx组件中，无法实现点击加一与滚动事件绑定的交互；而对于A.tsx中的代码就可以实现下面是打包的命令，打包实际上是通过vite的build函数实现的，打包与dev预览不同，我们要获取到该页面整体的html代码（SSG模式），所以需要使用上面提供的renderServerApp方法来获取路由页面的html代码然后拼接到页面中，然而react等打包的代码和一些逻辑代码都会写在assets/client-ssr.js中；如果出现了多个路由页面，我们就会打包生成多个html页面，然后这些路由信息也会记录在assets/client-ssr.js与该页面对应的js文件中下面是预览打包结果","objectID":"997794-8bcc71890ff24ecca3dce6f968c46321"},{"fileName":"实现原理-Rpress架构-简单复现 rpress dev","fileRoute":"/theory/theory_03_dev","zip_code":">干了什么？使用vite启动了一个可预览的服务在我们的项目中，主要使用了vite的`createServer`服务下面我们来简单复现一下rpress的dev服务（简单的demo）先用cac实现服务的命令然后就是`pluginIndexHtml`插件的实现逻辑下面有`client-ssr.tsx`中`react`渲染的逻辑，先回去页面中的id=\"root\"的div，然后通过react在里面渲染（当前不含路由与全局数据）所以，在开发环境下，我们用的还是`react`的CSR模式","objectID":"997794-2ad200e5d0c5f2ac5d976bb9fa5d1a54"},{"fileName":"实现原理-Rpress架构-简单复现 rpress build","fileRoute":"/theory/theory_04_build","zip_code":">干了什么？将一个服务打包下面是组件中的代码：`App.tsx`A.tsx`B.tsx下面是`server-ssr.ts`，主要是提供打包函数`renderServerApp`，你可以提供一个路由路径（比如`/a`），然后`StaticRouter`组件就会根据该路径将这个路径对应的页面转换为html字符串下面是`client-ssr.ts`，下面的renderApp函数在开发环境下是直接使用react的render来给#root组件绑定react实例，从而添加交互然而在生产环境下，我们将组件分为可交互组件与不可交互组件；对于不可交互组件，其实就是一个静态的html，所以不需要向其提供hydrates（何为hydrates？就是给该组件绑定事件）；而对于可交互组件，我们就需要向其提供hydrates，比如说下面的A组件就是需要交互的组件实现的效果：对于App.tsx与B.tsx组件中，无法实现点击加一与滚动事件绑定的交互；而对于A.tsx中的代码就可以实现下面是打包的命令，打包实际上是通过vite的build函数实现的，打包与dev预览不同，我们要获取到该页面整体的html代码（SSG模式），所以需要使用上面提供的renderServerApp方法来获取路由页面的html代码然后拼接到页面中，然而react等打包的代码和一些逻辑代码都会写在assets/client-ssr.js中；如果出现了多个路由页面，我们就会打包生成多个html页面，然后这些路由信息也会记录在assets/client-ssr.js与该页面对应的js文件中下面是预览打包结果","objectID":"997794-8bcc71890ff24ecca3dce6f968c46321"},{"fileName":"实现原理-Rpress架构-hydrates组件的思想","fileRoute":"/theory/theory_05_hy","zip_code":"首先我们这个系统架构里面分为两种组件，可交互组件和不可交互组件，不可交互组件就是指这种静态的一些页面，没有点击滚动等效果的页面，比如：然后就是不可交互组件，就是指有滚动事件，点击事件等页面，比如：（该页面会随着页面的滚动，绿色标签也会滚动，有一个交互效果）我们首先先获取整体页面的一个HTMLCSS代代码，然后给用户呈现出来，对于不可交互组件，它的组件渲染就已经完成了，因为它不需要一个进行事件绑定（hydrateRoot）的过程，这样做加快了一个页面的首屏加载时间，也不需要下载多余的hydrateRoot代码然后对于可交互的组件，当他的htmlcss渲染完成以后，我们还需要进行一个事件绑定hydrateRoot的过程。我们先获取到所有需要事件绑定的组件（比如下面带有__rpress的组件）然后下面的Js中会存在一个hydrateRoot的逻辑以及该组件的props然后浏览器就会完成事件绑定","objectID":"997794-782496d7354faac1035c9fda357e9b03"},{"fileName":"实现原理-Rpress架构-hydrates组件如何实现","fileRoute":"/theory/theory_06_hy_create","zip_code":"以下思路是在build模式下我们规定像这种：`<div__rpress/>`的组件为交互组件，他的逻辑处理与其他的非交互组件不同-首先，我们在react的插件中自定义配置babel打包的一些操作，将带有__rpress标签的组件添加一些信息比如：`<div__rpress/>`->`<div__rpress=\"``../../components/Aside/index!!RPRESS!!D:/font/mydemo/ReactPress/src/theme-default/Layout/DocLayout/index.tsx``\"/>`我们将一些路径数据添加在组件中-然后我们在react运行时拦截带有rpress标签的组件，然后将数据的信息记录到全局变量中我们一般记录两个详细信息：1.该组件的props数据（rpressProps）2.该组件的路径信息（rpressToPathMap）最后我们需要将这种组件包裹在一个div并且id为rpress的标签下面-将rpressProps与rpressToPathMap数据拼接到html中去然后在浏览器渲染时，先获取id为rpress的组件，将每个可交互组件的props放入，然后使用react的`hydrateRoot`（`hydrateRoot`会在渲染的过程中，不创建html标签，而是直接关联已有的。这样就避免了没必要的渲染），给已经存在的html代码绑定标签","objectID":"997794-8bc509a52f045f833e0f8861670361f6"},{"fileName":"实现原理-Rpress架构-部署时的rpress","fileRoute":"/theory/theory_20_serverRpress","zip_code":"部署时的rpress在项目中，我们可以通过`rpressserver[...args]`的方式来一键生成Linux的部署文件这是如何来完成的呢？我们首先会将打包好的代码都copy到目标文件夹中，然后生成一个`app.js`，在该文件中，是对里面的服务的启动代码我们在`app.js`中使用到了`sirv`来将所有的静态资源挂载，然后通过`child-process`来启动一个子进程，在子进程中我们下载`app.js`中需要的所有依赖","objectID":"997794-864ccff0907edfa73566a39cf399b18c"},{"fileName":"实现原理-获取路由数据-关于路由","fileRoute":"/theory/theory_07_route","zip_code":"如何将用户写的文件都转换为页面中的路由呢？首先，我们在服务器端写一个插件（pluginRoutes）来解析用户写的路由文件在这个插件中，我们先遍历用户的docs文件夹，将可以转换为路由页面的文件找出来，然后在这个插件中返回以下的数据path为对应的路由页面的路径，preload则加载页面中的信息（pageData），element则是用来生产页面的（就是类似于reac-router的配置文件，只是加了一个preload来获取mdx页面信息）然后将这些数据作为插件的返回值，我们就可以在下面的过程中获取到这些路由数据首先是对于开发环境下，我们直接引用client-entry里面的逻辑，采用render的方式来说生成页面，在每一个页面中，我们会根据pageType来使用不同的组件渲染页面，如果是docs类型的页面我们就会采用element来生产页面但对于生产环境则不一样，生产环境要的是多个html页面，在页面html生成时（服务器生产html字符串时），我们需要通过StaticRouter来生成单个html页面，我们会提供一个renderHtml函数来生产html字符串（renderToStringAPI）pageData是什么？pageData是页面的数据，对于home页面，里面会存在一些数据，然后下面的组件通过这些数据进行渲染；对于docs页面，里面则是使用默认的数据，然后调用useRoutesAPI集中管理页面（根据页面路径解析页面）我们在生产环境下打包时，需要使用开发环境下的代码（因为生产环境下的代码只有hydrateRoot的Js逻辑代码，没有css，以及一些依赖库的代码），我们会将开发环境下的css以及依赖代码打包完成供html页面使用，对于html代码自身的逻辑都写在了hydrateRoot的script标签里面","objectID":"997794-bbadcd12394ed527a79fe42a83d834f0"},{"fileName":"实现原理-获取路由数据-关于用户自定义配置","fileRoute":"/theory/theory_08_config","zip_code":"在我们的项目中，用户可以自定义配置路由，home页面等数据，这是如何实现的呢？首先，用户可以在文件夹书写config.ts配置，配置内容如下完成配置之后，就需要在打包时读取到这些配置，我们就需要通过vite插件来导出这些配置在vite打包启动时，我们先扫描用户自定义文件夹下面的配置文件（config.ts/js），然后通过vite的loadConfigFromFileAPI来读取文件里面的内容，然后将用户自定义配置传递给pluginConfig插件，再由插件导出里面的内容供给开发中使用里面也包括对于路由的配置pluginRoutes插件会获取所有的路由页面，而pluginConfig则是用来配置路由规则（配置顶部栏和侧边栏的路由跳转规则）","objectID":"997794-c1783795f118aa9735ad7325c2593f89"},{"fileName":"实现原理-获取tocs数据-Mdx文件处理","fileRoute":"/theory/theory_09_mdxHandle","zip_code":"我们会先获取到所有符合页面路由的文件，然后会把这些文件都交给createMdxPlugins插件来转换为jsx我们是如何将mdx文件转换为html文件的呢？这也是通过我们的自定义插件createMdxPlugins来实现的首先，我们基本上是通过`@mdx-js/rollup`插件来实现的，先讲一下这个插件能干什么？我们通过`@mdx-js/mdx`的node操作来复现`@mdx-js/rollup`的操作->所以，`@mdx-js/rollup`插件的操作大致是将mdx文件转换为jsx类型的文件，我们项目中的转换方式也是使用这个插件，转换为jsx文件之后，我们在后续会通过renderToStringAPI来将jsx代码转换为html代码在里面我们还可以配置导出的元信息（remarkMdxFrontmatter），也就是home组件中的一些组件信息在里面，我们还需要将代码块的html格式修改一下，这里面实现方法是在里面加了一个插件rehypePluginPreWrapperrehypePluginPreWrapper插件大致通过遍历当前所有dom，然后找到符合的，再修改里面的html","objectID":"997794-853113caf83049304fcfc79d942e6fd4"},{"fileName":"实现原理-获取tocs数据-获取Tocs","fileRoute":"/theory/theory_10_getTocs","zip_code":"下面我们来讲解以下如何根据mdx文件中的内容来获取tocs，下面就是tocs获取方式：先遍历获取mdx内容中所有符合条件的标题（h1，title）与tocs（h2-h5，tocs），然后把这些信息都放入到mdx的元信息中我们就可以在后面通过导入的方式获取到这些信息","objectID":"997794-56ebb282ebeebf8c37a656cfd76ffd82"},{"fileName":"实现原理-获取tocs数据-处理docs逻辑","fileRoute":"/theory/theory_13_handleDocsScroll","zip_code":"在存在`Aside`组件的页面中，首先是对于Aside组件中，我们点击某一个标题，就会跳转到目标的hash标题处然后是对于页面滚动，tocs激活的标题连带跳到目标标题。我们会有一个给页面添加一个滚动事件（还加了节流）在滚动事件中，先找到名字为.header-anchor的类（所有文章内容中的h2-h5标题），然后遍历每一个标题，根据下面的图判断找到之后，根据下标找到Aside中的需要激活的元素位置，然后激活即可","objectID":"997794-4fb658f277b55697782214cadfe2cfd7"},{"fileName":"实现原理-关于热更新-vite的HMR","fileRoute":"/theory/theory_14_viteHMR","zip_code":"什么是HMR?在vite的更新机制中，默认情况会全局更新，但是我们也可以让程序局部更新，这就需要使用到HMR机制（HotModuleReplacement）下面是HMR中主要函数的TS类型为了更好的查看效果，我们使用`pnpmcreatevitehmr-app----templatevanill`命令来创建一个纯Ts项目下面是原来的代码稍稍改了一点然后，我们如果修改里面的代码内容的话，代码会全局更新，下面是更新效果我们可以看见，网络请求了所有的数据，也就是全局更新，然而，vite也提供了相关的局部更新API，也就是我们上面说的我们可以发现，如果有文件更新了，下面使用了ImportMeta的API，那么就会使用HMR的更新机制，只会更新自身文件但是，如果我们在import回调中获取mker的值的时候，会无法获取其值这是为何？因为我们在页面中没有导出这些值这里就可以正常更新了我们也可以这样写对于上面这种函数的形式，当main.ts文件更新时，会更新全局的文件，但当./counter.ts或者./counter2.ts文件更新时，只会更新局部","objectID":"997794-7e81ee0b665123154c9a7aedb8218ecd"},{"fileName":"实现原理-关于热更新-预览状态下的热更新","fileRoute":"/theory/theory_16_devhmr","zip_code":"##用户配置修改导致热更新也就是说，当用户的自定义配置config.ts修改时，我们就会让程序重新启动，从而实现配置更新实现思路：在cac启动服务时，添加一个重启的钩子，透传到插件配置里面然后我们透传到用户自定义配置插件中文件修改时，以用户自定义配置的路径为判断，判断文件是否修改，如果修改那就重启服务##Mdx文件修改时的热更新看这个之前，可以先看看之前的文章，关于HMR机制也就是，我们自定义的mdx文件更新时，会导致路由页面相继更新，而且我们的页面状态会保持实现方式：先谈谈vite的组件更新机制1.监听文件变动2.构建侧确定热更新的边界模块3.浏览器侧执行更新逻辑最关键的在于第二步和第三步，而Vite使用了import.meta.hot.acceptAPI来实现了这两步下面讲一下该API的用法-直接调用。-传入一个回调函数。-传入一个路径数组+回调函数。在发生热更新的时候，Vite只会更新局部的模块，并不会重新编译所有的模块，那么边界模块就显得十分关键了，Vite找到它之后，只会更新这个边界模块以及它所依赖的模块。Vite是如何通过这个API确定热更新边界的呢？对此，大家只需要记住一句话:**谁接受模块的更新，谁就是热更新的边界**前两种调用方式即**直接调用**或者**传入一个回调**，属于自接受的形式，模块接受自身的更新，当模块内容发生变动时，Vite会将模块的代码重新执行一遍，如果传入了回调，会将模块的最新信息作为入参，执行回调。第三中调用方式中，比如:当前模块会接受index.mdx的更新，那么当index.mdx发生变动时，当前模块会成为热更新的边界模块这是Vite底层热更新的机制，虽然能做到模块级别的热更新，但没有办法达到组件级别的粒度，我们还需要做到组件级别的状态保存和恢复，这一点在不同的前端框架会有不同的处理方式。以React为例，组件的热更新主要由`@vitejs/plugin-react`这个插件来进行处理，而这个插件会依赖`react-refresh`，通过在组件中插入react-refresh相关的运行时代码来实现React组件的热更新。值得注意的是，这个插件也会在React组件所在的模块中插入`import.meta.hot.accept`的调用语句，当内容发生变动时，将组件的代码重新执行一遍，而由于有react-refresh相关的代码存在，组件的状态可以得到保存和恢复，也就实现了组件级别的热更新效果。那么问题来了：为什么之前的`index.mdx`热更新失败了呢？表面原因是Vite将其热更新的边界判断成了父组件的模块，而更深层的原因在于`@vitejs/plugin-react`没有在`index.mdx`的编译过程中注入`react-refresh`运行时代码以及`import.meta.hot.accept`调用语句。`@vitejs/plugin-react`内部只会为**React组件**注入这些代码，而它是如何判断一个模块是否是一个React组件的呢？>模块所有的导出必须是大写字母开头。以这个标准来看，`index.mdx`的模块结果并不符合要求，因为我们之前注入了诸如`frontmatter`、`toc`字段的导出，这些字段并不是以大写字母开头，因此整个模块会跳过react插件的处理，不会注入热更新相关的代码。那么我们如何来解决这个问题呢？有两个思路:1.将所有导出换成大写字母开头，来兼容react插件。2.编写自定义插件，手动注入热更新相关的代码。在处理mdx的插件中，添加一个mdx热更新处理的插件pluginMdxHMR()在下面的插件中，我们在代码babel编译的时候进行处理，如果代码是以.mdx为结尾的，那么我们就在最后加上import.meta.hot.accept()来添加局部热更新然后在热更新配置中，我们定义了一个热更新的事件，他会派发到react组件中，下面是对更新事件监听的自定义Hook我们的更新过程是采用import(...+时间戳)的方式来更新","objectID":"997795-aebd0ddefff09e5e382894b98057584c"},{"fileName":"实现原理-编译babel-关于插件@babel_helper-plugin-utils","fileRoute":"/theory/theory_19_babel","zip_code":"我们通常需要使用babel来将一些es6或者更高的版本编译为浏览器可以运行的版本，这里面就需要使用到babel来进行版本降级，我们在使用babel的过程中，如果需要在babel中添加一些插件，就需要使用到@babel/helper-plugin-utils库babel流程：我们先安装该库>npminstall--save-dev@babel/helper-plugin-utils然后使用该插件提供了declare函数，可以自定义插件declare函数需要返回一个配置选项对象，该对象可以包括以下属性：-pre：一个函数，用于在遍历AST节点之前进行的操作。-visitor：一个对象，用于定义遍历AST节点时对各种节点的处理方法。-post：一个函数，用于在遍历AST节点之后进行的操作。我们一般在visitor对象中操作，达到统一处理的效果；以下面的代码为例子，我们想要将__rpress属性添加一些值（比如添加组件名字加路径）首先，我们需要统一处理代码中所有的组件标签类型的节点（`<Com/>`），这就需要在JSXOpeningElement中进行处理我们可以在处理之前把这些代码放在AST语法树网站中解析一下，下面是目标组件的解析结果（`<Com__rpress/>`）然后我们就可以处理所有类型为JSXIdentifier的节点（标签类型节点）1.获取到他的标签名字（Com）2.通过组件名字，然后查找到他的import引用类型（ImportDeclaration），再获取该标签的引用路径（./Com）3.如果该标签节点有__rpress属性，就添加__rpress的属性信息为`Com%%%./Com自此，我们介绍了如何通过@babel/helper-plugin-utils插件来给babel编译时添加插件，我们项目中的使用方法也大致如此","objectID":"997795-4f849c75267c859f4b3608c81beae910"},{"fileName":"实现原理-其他配置-格式化与测试","fileRoute":"/theory/theory_11_formatAndTest","zip_code":"该项目中，为了规范化的开发，我们使用了`eslint`，`husky`，`vitest`等依赖首先是对于`eslint`，我们的项目中，eslint与prettier一起使用，下面先安装依赖>pnpmieslinteslint-plugin-reacteslint-plugin-react-hooks@typescript-eslint/parser@typescript-eslint/eslint-plugin-D>pnpmiprettiereslint-plugin-prettiereslint-config-prettier##eslint安装完成之后，我们配置.eslintrc.cjs配置文件接下来，我们会排除一些不需要的文件，写在了.eslintignore文件中然后，我们配置prettier，首先是.prettierrc.json文件然后是.prettierignore文件然后，我们就可以在packet.json中配置eslint的自动修复命令至此，我们就完成了代码的格式化工作，我们可以通过`pnpmlint`命令来格式化代码##husky接下来，我们要配置husky来在git提交代码时自动格式化代码先来添加依赖>pnpmihusky-D>pnpmicommitlint@commitlint/cli@commitlint/config-conventional-D然后我们来初始化husky，即执行下面的脚本>npxhuskyinstall下面我们来挂载pre-commit的执行事件>npxhuskyadd.husky/pre-commit\"npmrunlint\"然后我们在packet.json中添加脚本命令，有了该命令，我们在pnpmi之后会直接下载husky>\"prepare\":\"huskyinstall\"然后，我们在.commitlintrc.cjs文件中配置然后执行以下脚本>npxhuskyadd.husky/commit-msg\"npx--no-installcommitlint--edit\\\"$1\\\"\"至此，我们git提交时，如果commit信息不规范，就会有报错产生但是，我们发现，我们提交时还是会有全量的代码检查，这会有些耗时，所以，我们使用lint-staged依赖来仅仅对新增的文件内容进行检查即可首先添加依赖>pnpmilint-staged-D然后到package.json中新增一些内容接着进入.husky/pre-commit脚本中，修改一下其中的内容至此，我们完成了husky的配置##vitest这是一个测试的依赖首先，下载依赖>pnpmivitest-D然后，在`vitest.config.ts`中进行配置然后在packet.json中新增脚本下面是测试的一些语法","objectID":"997795-8b3d32e8cb6491fc92087984861dd90e"},{"fileName":"实现原理-其他配置-UnoCSS","fileRoute":"/theory/theory_12_UnoCSS","zip_code":"##配置UnoCSS配置文档：css开发文档：icon文档（carbon）：UnoCSS是一个原子化的CSS，可以在类名中直接书写类似于CSS属性的类名，也可以自定义CSS类名规则下面来讲一下如何使用首先下载UnoCSS依赖与icon图标集>pnpmiunocss>pnpmi@iconify-json/carbon然后，（如果你用的是vite来配置），直接在vite中导入插件即可，当然，也可以在里面配置新的类名规则至此，我们就完成了基本配置，下面使用即可（这是在普通项目中的配置，至于到vite开发中，将上面的配置写入插件即可）##关于主题切换首先，我们是如何实现主题切换的我们在var.css中会声明两种颜色主题的颜色变量在默认情况下，我们会使用:root下的颜色但是，我们点击切换主题颜色之后，会给document.documentElement添加名为dark的class类名这样，我们的颜色变量就会改为.dark下面的颜色变量","objectID":"997795-ec8f16ca2b9bd210111afc0fac146696"},{"fileName":"实现原理-其他配置-关于helmet","fileRoute":"/theory/theory_15_helmet","zip_code":"这是一个可以根据不同的页面提供不同的页面标签信息的插件下面是使用过程首先安装插件>npmireact-helmet-async我们到client-ssr.tsx中引入react-helmet-async:在ssr-entry中也是如此然后在html字符串页面中添加helmet信息`然后在Layout页面中加入","objectID":"997795-f1b98a8a5a682caa3fa377959079aa0c"},{"fileName":"实现原理-其他配置-EsBuild打包","fileRoute":"/theory/theory_17_esbuild","zip_code":"我们在项目中，因为打包react多依赖的问题，我们需要单独将react相关的依赖打包故，我们使用了esbuild来打包这里就讲一下里面对一些插件的处理应该如何书写，其他的可以API可以通过Ts来查看文档写看一下源码```typescriptasyncfunctionpreBundle(deps:string先来讲讲这几个插件干了什么？在react的依赖包中，导出的格式为node模式下的导出，这几个插件将node的导出模式改为esm的格式（默认导出+具名导出）然后讲一讲里面的几个钩子函数-onResolve，这个钩子函数是来处理路径解析的，也就是说，当解析路径的时候会触发该钩子，比如esbuild解析到import...from...时，就会去解析路径；在路径解析的第一个参数中有一个filter属性，顾名思义，就是用来删选符合的路径那么这个插件中干了什么呢？在这个插件中，我们找到了依赖包最顶层的入口文件，然后给这个入口文件标记，在下面的onLoad钩子中处理那么我们应该如何操作呢？我们先获取该模块的父模块路径，如果该模块没有父模块路径，那么就代表这是顶层模块了，是顶层模块就加入namespace命名空间，然后在下面的onLoad导出的时候导出自定义的内容；我们在返回数据时，第一个需要放是否要加入namespace，第二个要加上该文件的绝对路径完成了标记以后，就可以在下面的onLoad中导出esm格式的数据了-在onLoad钩子中，他能够返回自定义的内容在该钩子中，我们先require导入数据，然后再使用esm格式具名导出和默认导出","objectID":"997795-21b14a05aaae7eca115b2fa185363574"},{"fileName":"实现原理-其他配置-Rollup打包","fileRoute":"/theory/theory_18_rollup_build","zip_code":"在项目中，我们也会使用到rollup来进行打包，也就是vite的默认打包插件Rollup我们只要使用到vite的build打包API就会使用到Rollup来进行打包下面讲一讲Rollup打包机制讲讲Rollup工作流中的build过程1.首先经历options钩子进行配置的转换，得到处理后的配置对象。2.随之Rollup会调用buildStart钩子，正式开始构建流程。3.Rollup先进入到resolveId钩子中解析文件路径(从input配置指定的入口文件开始)。4.Rollup通过调用load钩子加载模块内容。5.紧接着Rollup执行所有的transform钩子来对模块内容进行进行自定义的转换，比如babel转译。6.现在Rollup拿到了模块内容，接下来就是进行AST分析，得到所有的import内容，调用moduleParsed钩子。如果是普通的import，则执行resolveId钩子，继续回到步骤3；如果是动态import，则执行resolveDynamicImport钩子解析路径，如果解析成功，则回到步骤4加载模块，否则回到步骤3通过resolveId解析路径。7.直到所有的import都解析完毕，Rollup执行buildEnd钩子，Build阶段结束。当然，在Rollup解析路径的时候，即执行resolveId或者resolveDynamicImport的时候，有些路径可能会被标记为external(翻译为排除)，也就是说不参加Rollup打包过程，这个时候就不会进行load、transform等等后续的处理了。下面来根据项目中的例子来学习一下rollup的打包流程我来讲一下上面的打包流程1.第一次运行到resolveId钩子时，id为rpress:inject会被拦截，然后返回该id2.在load时，如果id为rpress:inject，拦截，将返回结果改为我们自定义的返回结果，在我们的返回结果中，是以下的格式由于Com组件的路径存在问题，所以我们需要在插件中处理一下3.接下来，rollup会做AST语法树转换，由于里面有import语句存在，接着返回到resolveId这一步，进行处理；在resolveId钩子中，我们会对带有特殊标识（MASK_SPLITTER）的import路径id处理，为了替换之后的路径可以被其他插件进行处理，通过this.resolve来处理。this.resolve处理之后会返回一个对象，下面是对象的大致内容总结：在resolveId中，将我们之前写的不规范的导入路径做了规范化处理，通过this.resolve函数来处理！讲讲this.resolve(相对路径，绝对路径)然后该函数可以通过这个绝对路径与相对路径找到这个**相对路径的绝对路径**，并且返回一个对象，可以给接下来的插件处理里面的内容","objectID":"997795-27409d44e3ca71cba78e6143727fd425"}]